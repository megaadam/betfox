// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MarketDefinition market definition
//
// swagger:model MarketDefinition
type MarketDefinition struct {

	// bet delay
	BetDelay int32 `json:"betDelay,omitempty"`

	// betting type
	// Enum: [ODDS LINE RANGE ASIAN_HANDICAP_DOUBLE_LINE ASIAN_HANDICAP_SINGLE_LINE]
	BettingType string `json:"bettingType,omitempty"`

	// bsp market
	BspMarket bool `json:"bspMarket,omitempty"`

	// bsp reconciled
	BspReconciled bool `json:"bspReconciled,omitempty"`

	// complete
	Complete bool `json:"complete,omitempty"`

	// country code
	CountryCode string `json:"countryCode,omitempty"`

	// cross matching
	CrossMatching bool `json:"crossMatching,omitempty"`

	// discount allowed
	DiscountAllowed bool `json:"discountAllowed,omitempty"`

	// each way divisor
	EachWayDivisor float64 `json:"eachWayDivisor,omitempty"`

	// event Id
	EventID string `json:"eventId,omitempty"`

	// The Event Type the market is contained within.
	EventTypeID string `json:"eventTypeId,omitempty"`

	// in play
	InPlay bool `json:"inPlay,omitempty"`

	// Definition of a markets key line selection (for valid markets), comprising the selectionId and handicap of the team it is applied to.
	KeyLineDefinition *KeyLineDefinition `json:"keyLineDefinition,omitempty"`

	// For Handicap and Line markets, the lines available on this market will be between the range of lineMinUnit and lineMaxUnit, in increments of the lineInterval value. e.g. If unit is runs, lineMinUnit=10, lineMaxUnit=20 and lineInterval=0.5, then valid lines include 10, 10.5, 11, 11.5 up to 20 runs.
	LineInterval float64 `json:"lineInterval,omitempty"`

	// For Handicap and Line markets, the maximum value for the outcome, in market units for this market (eg 100 runs).
	LineMaxUnit float64 `json:"lineMaxUnit,omitempty"`

	// For Handicap and Line markets, the minimum value for the outcome, in market units for this market (eg 0 runs).
	LineMinUnit float64 `json:"lineMinUnit,omitempty"`

	// market base rate
	MarketBaseRate float64 `json:"marketBaseRate,omitempty"`

	// market time
	// Format: date-time
	MarketTime strfmt.DateTime `json:"marketTime,omitempty"`

	// market type
	MarketType string `json:"marketType,omitempty"`

	// number of active runners
	NumberOfActiveRunners int32 `json:"numberOfActiveRunners,omitempty"`

	// number of winners
	NumberOfWinners int32 `json:"numberOfWinners,omitempty"`

	// open date
	// Format: date-time
	OpenDate strfmt.DateTime `json:"openDate,omitempty"`

	// persistence enabled
	PersistenceEnabled bool `json:"persistenceEnabled,omitempty"`

	// Definition of the price ladder type and any related data.
	PriceLadderDefinition *PriceLadderDefinition `json:"priceLadderDefinition,omitempty"`

	// race type
	RaceType string `json:"raceType,omitempty"`

	// The market regulators.
	Regulators []string `json:"regulators"`

	// runners
	Runners []*RunnerDefinition `json:"runners"`

	// runners voidable
	RunnersVoidable bool `json:"runnersVoidable,omitempty"`

	// settled time
	// Format: date-time
	SettledTime strfmt.DateTime `json:"settledTime,omitempty"`

	// status
	// Enum: [INACTIVE OPEN SUSPENDED CLOSED]
	Status string `json:"status,omitempty"`

	// suspend time
	// Format: date-time
	SuspendTime strfmt.DateTime `json:"suspendTime,omitempty"`

	// timezone
	Timezone string `json:"timezone,omitempty"`

	// turn in play enabled
	TurnInPlayEnabled bool `json:"turnInPlayEnabled,omitempty"`

	// venue
	Venue string `json:"venue,omitempty"`

	// version
	Version int64 `json:"version,omitempty"`
}

// Validate validates this market definition
func (m *MarketDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBettingType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyLineDefinition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriceLadderDefinition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunners(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettledTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspendTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var marketDefinitionTypeBettingTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODDS","LINE","RANGE","ASIAN_HANDICAP_DOUBLE_LINE","ASIAN_HANDICAP_SINGLE_LINE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketDefinitionTypeBettingTypePropEnum = append(marketDefinitionTypeBettingTypePropEnum, v)
	}
}

const (

	// MarketDefinitionBettingTypeODDS captures enum value "ODDS"
	MarketDefinitionBettingTypeODDS string = "ODDS"

	// MarketDefinitionBettingTypeLINE captures enum value "LINE"
	MarketDefinitionBettingTypeLINE string = "LINE"

	// MarketDefinitionBettingTypeRANGE captures enum value "RANGE"
	MarketDefinitionBettingTypeRANGE string = "RANGE"

	// MarketDefinitionBettingTypeASIANHANDICAPDOUBLELINE captures enum value "ASIAN_HANDICAP_DOUBLE_LINE"
	MarketDefinitionBettingTypeASIANHANDICAPDOUBLELINE string = "ASIAN_HANDICAP_DOUBLE_LINE"

	// MarketDefinitionBettingTypeASIANHANDICAPSINGLELINE captures enum value "ASIAN_HANDICAP_SINGLE_LINE"
	MarketDefinitionBettingTypeASIANHANDICAPSINGLELINE string = "ASIAN_HANDICAP_SINGLE_LINE"
)

// prop value enum
func (m *MarketDefinition) validateBettingTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, marketDefinitionTypeBettingTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MarketDefinition) validateBettingType(formats strfmt.Registry) error {
	if swag.IsZero(m.BettingType) { // not required
		return nil
	}

	// value enum
	if err := m.validateBettingTypeEnum("bettingType", "body", m.BettingType); err != nil {
		return err
	}

	return nil
}

func (m *MarketDefinition) validateKeyLineDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyLineDefinition) { // not required
		return nil
	}

	if m.KeyLineDefinition != nil {
		if err := m.KeyLineDefinition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("keyLineDefinition")
			}
			return err
		}
	}

	return nil
}

func (m *MarketDefinition) validateMarketTime(formats strfmt.Registry) error {
	if swag.IsZero(m.MarketTime) { // not required
		return nil
	}

	if err := validate.FormatOf("marketTime", "body", "date-time", m.MarketTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MarketDefinition) validateOpenDate(formats strfmt.Registry) error {
	if swag.IsZero(m.OpenDate) { // not required
		return nil
	}

	if err := validate.FormatOf("openDate", "body", "date-time", m.OpenDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MarketDefinition) validatePriceLadderDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.PriceLadderDefinition) { // not required
		return nil
	}

	if m.PriceLadderDefinition != nil {
		if err := m.PriceLadderDefinition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("priceLadderDefinition")
			}
			return err
		}
	}

	return nil
}

func (m *MarketDefinition) validateRunners(formats strfmt.Registry) error {
	if swag.IsZero(m.Runners) { // not required
		return nil
	}

	for i := 0; i < len(m.Runners); i++ {
		if swag.IsZero(m.Runners[i]) { // not required
			continue
		}

		if m.Runners[i] != nil {
			if err := m.Runners[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MarketDefinition) validateSettledTime(formats strfmt.Registry) error {
	if swag.IsZero(m.SettledTime) { // not required
		return nil
	}

	if err := validate.FormatOf("settledTime", "body", "date-time", m.SettledTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var marketDefinitionTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INACTIVE","OPEN","SUSPENDED","CLOSED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		marketDefinitionTypeStatusPropEnum = append(marketDefinitionTypeStatusPropEnum, v)
	}
}

const (

	// MarketDefinitionStatusINACTIVE captures enum value "INACTIVE"
	MarketDefinitionStatusINACTIVE string = "INACTIVE"

	// MarketDefinitionStatusOPEN captures enum value "OPEN"
	MarketDefinitionStatusOPEN string = "OPEN"

	// MarketDefinitionStatusSUSPENDED captures enum value "SUSPENDED"
	MarketDefinitionStatusSUSPENDED string = "SUSPENDED"

	// MarketDefinitionStatusCLOSED captures enum value "CLOSED"
	MarketDefinitionStatusCLOSED string = "CLOSED"
)

// prop value enum
func (m *MarketDefinition) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, marketDefinitionTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MarketDefinition) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *MarketDefinition) validateSuspendTime(formats strfmt.Registry) error {
	if swag.IsZero(m.SuspendTime) { // not required
		return nil
	}

	if err := validate.FormatOf("suspendTime", "body", "date-time", m.SuspendTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this market definition based on the context it is used
func (m *MarketDefinition) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateKeyLineDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePriceLadderDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRunners(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MarketDefinition) contextValidateKeyLineDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyLineDefinition != nil {
		if err := m.KeyLineDefinition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("keyLineDefinition")
			}
			return err
		}
	}

	return nil
}

func (m *MarketDefinition) contextValidatePriceLadderDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.PriceLadderDefinition != nil {
		if err := m.PriceLadderDefinition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("priceLadderDefinition")
			}
			return err
		}
	}

	return nil
}

func (m *MarketDefinition) contextValidateRunners(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Runners); i++ {

		if m.Runners[i] != nil {
			if err := m.Runners[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MarketDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MarketDefinition) UnmarshalBinary(b []byte) error {
	var res MarketDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
